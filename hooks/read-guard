#!/bin/bash
# Read guard: Block reads on large/bundled files
# Prevents agents from getting stuck on massive bundled JS files
#
# Input: JSON via stdin with tool_input.file_path
# Exit 0: Allow read
# Exit 2: Block read (message fed back to Claude)

set -euo pipefail

# Source shared library
source "${BASH_SOURCE[0]%/*}/lib/common.sh"

# Config
MAX_SIZE_MB=2
MAX_SIZE_BYTES=$((MAX_SIZE_MB * 1024 * 1024))

_warden_read_input || exit 0

# Extract file_path from tool_input
IFS=$'\t' read -r FILE_PATH < <(_warden_parse_tool_input file_path)

if [[ -z "$FILE_PATH" ]]; then
    exit 0  # No file_path, let it through
fi

# PHASE 3 OPTIMIZATION: Compile patterns into single regex (1 match instead of 17)
BUNDLED_PATTERN_RE='(node_modules/|/dist/|/build/|\.min\.js$|\.bundle\.js$|expo-downloads/|\.chunk\.js$|/vendor/|/__generated__/|package-lock\.json$|yarn\.lock$|pnpm-lock\.yaml$|Cargo\.lock$|poetry\.lock$|composer\.lock$|Gemfile\.lock$|go\.sum$)'

if [[ "$FILE_PATH" =~ $BUNDLED_PATTERN_RE ]]; then
    WARDEN_TOOL_NAME="Read" WARDEN_COMMAND="$FILE_PATH" _warden_emit_block "read_bundled" 8000
    echo "Blocked: '$FILE_PATH' appears to be a bundled/generated file. These are not source code - search for the original source instead." >&2
    exit 2
fi

# Check file size (if file exists)
if [[ -f "$FILE_PATH" ]]; then
    # Cross-platform stat (Linux || macOS)
    FILE_SIZE=$(stat -c%s "$FILE_PATH" 2>/dev/null || stat -f%z "$FILE_PATH" 2>/dev/null || echo "0")

    if [[ "$FILE_SIZE" -gt "$MAX_SIZE_BYTES" ]]; then
        # bc may not be available everywhere; use awk as fallback
        SIZE_MB=$(awk "BEGIN { printf \"%.1f\", $FILE_SIZE / 1024 / 1024 }" 2>/dev/null || echo "?")
        WARDEN_TOOL_NAME="Read" WARDEN_COMMAND="$FILE_PATH" _warden_emit_block "read_oversize" 25000
        echo "Blocked: '$FILE_PATH' is ${SIZE_MB}MB (max ${MAX_SIZE_MB}MB). Large files are typically bundled/minified - find the original source code instead." >&2
        exit 2
    fi
fi

exit 0
