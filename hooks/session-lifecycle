#!/usr/bin/env bash
# session-lifecycle: Unified session start/end tracking (merged from session-start + session-end)
# Dispatches on hook_event_name field
set -euo pipefail

# Source shared library
source "${BASH_SOURCE[0]%/*}/lib/common.sh"

_warden_read_input || exit 0

# Determine which event we're handling
HOOK_EVENT=$(printf '%s' "$WARDEN_INPUT" | jq -r '.hook_event_name // "SessionStart"' 2>/dev/null)

SESSION_ID=$(_warden_parse_session_id)
SESSION_ID=$(_warden_sanitize_id "$SESSION_ID")
[[ -z "$SESSION_ID" ]] && SESSION_ID="unknown"

AGENT_STATS="$HOME/.claude/agent-stats.csv"
LOG_FILE="$HOME/.claude/session-log.txt"

# ============================================================================
# SESSION START
# ============================================================================
if [[ "$HOOK_EVENT" == "SessionStart" ]]; then
  if [[ "$SESSION_ID" != "unknown" ]]; then
    mkdir -p "$HOME/.claude/.session-times"
    mkdir -p "$WARDEN_SESSION_BUDGET_DIR"
    mkdir -p "$WARDEN_STATE_DIR"

    date +%s > "$HOME/.claude/.session-times/$SESSION_ID.start"
    date +%s.%N > "$WARDEN_STATE_DIR/.session_start"

    # Snapshot budget at session start (if budget-cli is installed)
    if command -v budget-cli &>/dev/null; then
      budget-cli export > "$WARDEN_SESSION_BUDGET_DIR/$SESSION_ID.start.json" 2>/dev/null || true
      # Refresh Prometheus textfile metrics
      BUDGET_EXPORTER="$HOME/dev/claude-code-monitoring-guide/budget-exporter.sh"
      [[ -x "$BUDGET_EXPORTER" ]] && { "$BUDGET_EXPORTER" 2>/dev/null & disown; }
    fi

    # Initialize unified agent stats CSV with header if needed
    if [[ ! -f "$AGENT_STATS" ]]; then
      echo "timestamp,agent_id,agent_category,agent_type,duration_seconds,session_id,status" > "$AGENT_STATS"
    fi

    # Log terminal agent start
    echo "$(date -Iseconds),terminal-$SESSION_ID,terminal,main,0,$SESSION_ID,started" >> "$AGENT_STATS"
  fi

  exit 0
fi

# ============================================================================
# SESSION END
# ============================================================================
if [[ "$HOOK_EVENT" == "SessionEnd" ]]; then
  REASON=$(printf '%s' "$WARDEN_INPUT" | jq -r '.reason // ""' 2>/dev/null)
  RESET_REASON_FILE="$WARDEN_STATE_DIR/reset-reason"
  SESSION_COST_LOG="$HOME/.claude/.monitoring/session-costs.csv"

  # Calculate terminal agent duration
  SESSION_START_FILE="$HOME/.claude/.session-times/$SESSION_ID.start"
  if [[ -f "$SESSION_START_FILE" ]]; then
    START_EPOCH=$(cat "$SESSION_START_FILE")
    END_EPOCH=$(date +%s)
    DURATION=$((END_EPOCH - START_EPOCH))
    DURATION_MIN=$((DURATION / 60))

    # Log terminal agent completion
    echo "$(date -Iseconds),terminal-$SESSION_ID,terminal,main,$DURATION,$SESSION_ID,completed" >> "$AGENT_STATS"

    # Track budget delta for this session (if budget-cli is installed)
    START_BUDGET_FILE="$WARDEN_SESSION_BUDGET_DIR/$SESSION_ID.start.json"
    if [[ -f "$START_BUDGET_FILE" ]] && command -v budget-cli &>/dev/null; then
      START_CONSUMED=$(jq -r '.consumed // 0' "$START_BUDGET_FILE" 2>/dev/null || echo 0)
      END_JSON=$(budget-cli export 2>/dev/null || echo '{"consumed":0}')
      END_CONSUMED=$(echo "$END_JSON" | jq -r '.consumed // 0')
      DELTA=$((END_CONSUMED - START_CONSUMED))

      # Initialize CSV if needed
      mkdir -p "$(dirname "$SESSION_COST_LOG")"
      if [[ ! -f "$SESSION_COST_LOG" ]]; then
        echo "timestamp,session_id,duration_seconds,budget_start,budget_end,budget_delta,subagent_count" > "$SESSION_COST_LOG"
      fi

      # Count subagents for this session
      SUBAGENT_COUNT=$(grep ",$SESSION_ID," "$AGENT_STATS" 2>/dev/null | grep ",subagent," | grep ",completed" | wc -l || echo 0)

      # Log session cost
      echo "$(date -Iseconds),$SESSION_ID,$DURATION,$START_CONSUMED,$END_CONSUMED,$DELTA,$SUBAGENT_COUNT" >> "$SESSION_COST_LOG"

      # Refresh Prometheus textfile metrics
      BUDGET_EXPORTER="$HOME/dev/claude-code-monitoring-guide/budget-exporter.sh"
      [[ -x "$BUDGET_EXPORTER" ]] && { "$BUDGET_EXPORTER" 2>/dev/null & disown; }

      # Cleanup budget snapshot
      rm -f "$START_BUDGET_FILE"
    fi
  else
    DURATION="unknown"
    DURATION_MIN="unknown"
  fi

  END_TIME=$(date '+%Y-%m-%d %H:%M:%S')

  # === GHOST SUBAGENT REAPER ===
  # Force-complete orphaned subagents from THIS session only (safe with concurrent sessions)
  if [[ -d "$WARDEN_SUBAGENT_STATE_DIR" ]] && command -v budget-cli &>/dev/null; then
    for state_file in "$WARDEN_SUBAGENT_STATE_DIR"/*; do
      [[ -f "$state_file" ]] && [[ ! -L "$state_file" ]] || continue
      [[ "$(basename "$state_file")" == *.* ]] && continue  # skip .start and session- files
      grep -q "^SESSION_ID=${SESSION_ID}$" "$state_file" 2>/dev/null || continue
      ORPHAN_ID=$(basename "$state_file")
      budget-cli complete "$ORPHAN_ID" 2>/dev/null || true
      rm -f "$state_file" "$state_file.start"
    done
  fi

  # === STATE FILE CLEANUP ===
  # Purge stale state files older than 24 hours
  if [[ -d "$WARDEN_STATE_DIR" ]]; then
    find "$WARDEN_STATE_DIR" -maxdepth 1 -type f -name 'tool-count-*' -mmin +1440 -delete 2>/dev/null || true
    find "$WARDEN_STATE_DIR" -maxdepth 1 -type f -name 'tool-top-*' -mmin +1440 -delete 2>/dev/null || true
    find "$WARDEN_STATE_DIR" -maxdepth 1 -type f -name 'session-*' -mmin +1440 -delete 2>/dev/null || true
  fi
  if [[ -d "$WARDEN_SUBAGENT_STATE_DIR" ]]; then
    find "$WARDEN_SUBAGENT_STATE_DIR" -maxdepth 1 -type f -name '*.start' -mmin +1440 -delete 2>/dev/null || true
    find "$WARDEN_SUBAGENT_STATE_DIR" -maxdepth 1 -type f ! -name '.*' -mmin +1440 -delete 2>/dev/null || true
  fi

  # Log session end
  echo "[$END_TIME] Session ended: $SESSION_ID (duration: ${DURATION_MIN}m, dir: $PWD, reason: $REASON)" >> "$LOG_FILE"

  # Record reset reason for statusline
  if [[ -n "$REASON" ]]; then
    mkdir -p "$WARDEN_STATE_DIR"
    printf '%s|%s|%s\n' "$(date +%s)" "$REASON" "$SESSION_ID" > "$RESET_REASON_FILE"
  fi

  # === EVENTS.JSONL ROTATION (Phase 4 addition) ===
  EVENTS_FILE="$WARDEN_EVENTS_FILE"
  if [[ -f "$EVENTS_FILE" ]] && [[ $(stat -c %s "$EVENTS_FILE" 2>/dev/null || stat -f %z "$EVENTS_FILE" 2>/dev/null || echo 0) -gt 10485760 ]]; then
    mv "$EVENTS_FILE" "$EVENTS_FILE.1" 2>/dev/null || true
  fi

  exit 0
fi

# Unknown event - pass through
exit 0
