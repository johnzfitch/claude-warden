#!/bin/bash
# post-tool-use: Track session stats, truncate/suppress large Bash outputs
# Single state file per session, minimal I/O

set -o pipefail

# Source shared library
source "${BASH_SOURCE[0]%/*}/lib/common.sh"

_warden_read_input || exit 0

# Single jq call: extract all needed fields
read -r TOOL_NAME SESSION_ID OUTPUT_SIZE COMMAND < <(
    printf '%s' "$WARDEN_INPUT" | jq -r '[
        .tool_name // "",
        .session_id // "",
        (.tool_response.content[0].text // "" | length),
        (.tool_input.command // .tool_input.file_path // .tool_input.pattern // .tool_input.prompt // "")[0:200]
    ] | @tsv' 2>/dev/null
) || exit 0

# Export for shared library functions (sanitize session_id to prevent path traversal)
export WARDEN_TOOL_NAME="$TOOL_NAME"
export WARDEN_COMMAND="$COMMAND"
export WARDEN_SESSION_ID="$(_warden_sanitize_id "$SESSION_ID")"

[[ "$OUTPUT_SIZE" =~ ^[0-9]+$ ]] || OUTPUT_SIZE=0

# === TOOL OUTPUT SIZE TRACKING (Phase 1 observability) ===
# Emit for all tool calls to build baseline data before enforcement
if (( OUTPUT_SIZE > 0 )); then
    # Count lines (fast approximation: count newlines in first 50KB)
    OUTPUT_LINES=0
    if (( OUTPUT_SIZE <= 51200 )); then
        OUTPUT_LINES=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null | wc -l)
    else
        # For large outputs, sample first 50KB for line count estimate
        OUTPUT_LINES=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null | head -c 51200 | wc -l)
        # Validate before arithmetic to avoid bash errors on non-numeric input
        [[ "$OUTPUT_LINES" =~ ^[0-9]+$ ]] || OUTPUT_LINES=0
        # Extrapolate
        OUTPUT_LINES=$(( OUTPUT_LINES * OUTPUT_SIZE / 51200 ))
    fi
    [[ "$OUTPUT_LINES" =~ ^[0-9]+$ ]] || OUTPUT_LINES=0
    _warden_emit_output_size "$TOOL_NAME" "$OUTPUT_SIZE" "$OUTPUT_LINES" "$COMMAND"
fi

# === Session state: single file, single read+write ===
if [[ -n "$WARDEN_SESSION_ID" ]]; then
    STATE_FILE="$WARDEN_STATE_DIR/session-$WARDEN_SESSION_ID"
    mkdir -p "$WARDEN_STATE_DIR"

    # Read previous state (count|top_bytes|top_label|timestamp)
    PREV_COUNT=0; PREV_BYTES=0; PREV_LABEL=""; PREV_TS=0
    if [[ -f "$STATE_FILE" ]]; then
        IFS='|' read -r PREV_COUNT PREV_BYTES PREV_LABEL PREV_TS < "$STATE_FILE" 2>/dev/null
    fi
    [[ "$PREV_COUNT" =~ ^[0-9]+$ ]] || PREV_COUNT=0
    [[ "$PREV_BYTES" =~ ^[0-9]+$ ]] || PREV_BYTES=0

    NEW_COUNT=$((PREV_COUNT + 1))

    # Build tool label for top-output tracking
    TOP_LABEL="$PREV_LABEL"
    TOP_BYTES="$PREV_BYTES"
    if (( OUTPUT_SIZE > PREV_BYTES )); then
        TOP_BYTES="$OUTPUT_SIZE"
        if [[ "$TOOL_NAME" == "Bash" && -n "$COMMAND" ]]; then
            CMD="${COMMAND#"${COMMAND%%[![:space:]]*}"}"
            TOP_LABEL="Bash:${CMD%%[[:space:]]*}"
        else
            TOP_LABEL="$TOOL_NAME"
        fi
    fi
    # Sanitize TOP_LABEL for pipe delimiter (prevents state file corruption)
    TOP_LABEL="${TOP_LABEL//|/_}"

    # Single write: count|top_bytes|top_label|timestamp
    printf '%s|%s|%s|%s\n' "$NEW_COUNT" "$TOP_BYTES" "$TOP_LABEL" "$(date +%s)" > "$STATE_FILE"

    # Budget check every 50 calls (infrequent, fine to be slow)
    if (( NEW_COUNT % 50 == 0 )) && command -v budget-cli &>/dev/null; then
        ALERT_FILE="$WARDEN_STATE_DIR/budget-alert"
        UTIL=$(budget-cli export 2>/dev/null | jq -r '.utilization // 0' | cut -d. -f1)
        if [[ "$UTIL" =~ ^[0-9]+$ ]] && (( UTIL >= 90 )); then
            echo "CRITICAL|$UTIL|$(date +%s)" > "$ALERT_FILE"
            _warden_notify critical "Claude Budget" "${UTIL}%!"
        elif [[ "$UTIL" =~ ^[0-9]+$ ]] && (( UTIL >= 75 )); then
            PREV_LEVEL=$(cut -d'|' -f1 < "$ALERT_FILE" 2>/dev/null || echo "")
            [[ "$PREV_LEVEL" != "WARNING" && "$PREV_LEVEL" != "CRITICAL" ]] && {
                echo "WARNING|$UTIL|$(date +%s)" > "$ALERT_FILE"
                _warden_notify normal "Claude Budget" "${UTIL}%"
            }
        fi
    fi
fi

# === SUBAGENT DETECTION + CUMULATIVE BYTE TRACKING ===
TRANSCRIPT_PATH=$(_warden_parse_transcript_path)
IS_SUBAGENT=false
AGENT_ID=""

if _warden_is_subagent "$TRANSCRIPT_PATH"; then
    IS_SUBAGENT=true
    AGENT_ID=$(_warden_get_agent_id "$TRANSCRIPT_PATH")
fi

if [[ "$IS_SUBAGENT" == true && -n "$AGENT_ID" ]]; then
    BYTE_FILE="$WARDEN_SUBAGENT_STATE_DIR/$AGENT_ID.bytes"
    PREV_BYTES=0
    if [[ -f "$BYTE_FILE" ]]; then
        RAW=$(cat "$BYTE_FILE" 2>/dev/null || echo "0")
        if [[ "$RAW" == *"|"* ]]; then
            PREV_BYTES=$(echo "$RAW" | cut -d'|' -f1)
        fi
        [[ ! "$PREV_BYTES" =~ ^[0-9]+$ ]] && PREV_BYTES=0
    fi
    NEW_BYTES=$((PREV_BYTES + OUTPUT_SIZE))
    printf '%s|%s|%s\n' "$NEW_BYTES" "$TOOL_NAME" "$(date +%s)" > "$BYTE_FILE"
fi

# === TOOL LATENCY + TRACE SPAN ===
if _warden_compute_tool_latency "$TOOL_NAME"; then
    _warden_emit_latency "$TOOL_NAME" "$WARDEN_TOOL_LATENCY_MS" "$COMMAND"

    # Emit OTLP trace span (fire-and-forget)
    if [[ -f "${BASH_SOURCE[0]%/*}/lib/otel-trace.sh" ]]; then
        source "${BASH_SOURCE[0]%/*}/lib/otel-trace.sh"
        _warden_emit_trace_span \
            "$TOOL_NAME" \
            "$WARDEN_TOOL_START_NS" \
            "$WARDEN_TOOL_END_NS" \
            "$SESSION_ID" \
            "$COMMAND" \
            "$OUTPUT_SIZE" &
        disown
    fi
fi

# === SYSTEM REMINDER STRIP (all tools) ===
# <system-reminder> blocks are injected into tool_response text by Claude Code infra.
# They repeat per-call and compound across sessions. Strip before any further processing.
REMINDER_PRE_STRIPPED=false
if (( OUTPUT_SIZE > 50 )); then
    _RAW=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
    case "$_RAW" in
        *'<system-reminder>'*)
            _CLEANED=$(printf '%s' "$_RAW" | sed '/^<system-reminder>/,/^<\/system-reminder>/d')
            # Also strip trailing blank lines left by removal
            _CLEANED=$(printf '%s' "$_CLEANED" | sed -e :a -e '/^[[:space:]]*$/{ $d; N; ba; }')
            _CLEANED_SIZE=${#_CLEANED}
            _STRIPPED=$(( ${#_RAW} - _CLEANED_SIZE ))
            if (( _STRIPPED > 0 )); then
                _EMIT_ORIG_TEXT="$_RAW" _EMIT_FINAL_TEXT="$_CLEANED" \
                _warden_emit_event "truncated" "$OUTPUT_SIZE" "$_CLEANED_SIZE" "system_reminder"
                case "$TOOL_NAME" in
                    Bash|Grep|Glob|Task)
                        # Pre-clean for downstream truncation logic
                        OUTPUT="$_CLEANED"
                        OUTPUT_SIZE="$_CLEANED_SIZE"
                        REMINDER_PRE_STRIPPED=true
                        ;;
                    *)
                        # All other tools (Read/Write/Edit/etc): emit cleaned output, done
                        jq -n --arg text "$_CLEANED" '{"modifyOutput":$text}'
                        exit 0
                        ;;
                esac
            fi
            ;;
    esac
    unset _RAW _CLEANED _CLEANED_SIZE _STRIPPED
fi

# Truncate large outputs from Bash, Grep, Glob, Task (Read handled by read-compress)
# Subagent Reads also fall through: safety net when read-compress fails
case "$TOOL_NAME" in
    Bash|Grep|Glob|Task) ;;
    Read)
        if [[ "$IS_SUBAGENT" != true ]]; then
            _warden_emit_event "allowed" "$OUTPUT_SIZE" "$OUTPUT_SIZE"; _warden_suppress_ok
        fi
        ;;
    *) _warden_emit_event "allowed" "$OUTPUT_SIZE" "$OUTPUT_SIZE"; _warden_suppress_ok ;;
esac

# Helper: emit cleaned output if reminders were stripped, else suppress (pass through)
_exit_clean_or_suppress() {
    if [[ "$REMINDER_PRE_STRIPPED" == true ]]; then
        jq -n --arg text "$OUTPUT" '{"modifyOutput":$text}'
        exit 0
    fi
    _warden_suppress_ok
}

# Task-specific: extract structured lines instead of blind head+tail
# Agent results are prose-heavy but the useful content is bullets, steps, headers, file refs
# Runs BEFORE fast path since agent results (6-15KB) fall under the 20KB generic threshold
if [[ "$TOOL_NAME" == "Task" ]] && (( OUTPUT_SIZE > 6144 )); then
    # Need actual content for structured extraction
    if [[ "$REMINDER_PRE_STRIPPED" != true ]]; then
        OUTPUT=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
        OUTPUT_SIZE=${#OUTPUT}
    fi
    if (( OUTPUT_SIZE > 6144 )); then
        STRUCTURED=$(printf '%s' "$OUTPUT" | awk '
            /^[-*] /           { print; next }   # bullet points
            /^[0-9]+[.)]/      { print; next }   # numbered items
            /^#{1,4} /         { print; next }   # markdown headers
            /^[|]/             { print; next }   # table rows
            /^[[:space:]]*[-*] / { print; next } # indented bullets
            /^[a-zA-Z_.\/ ]*\.[a-z]{1,4}:[0-9]/ { print; next }  # standalone file:line refs
        ' | head -120)
        STRUCT_SIZE=${#STRUCTURED}
        if (( STRUCT_SIZE > 200 && STRUCT_SIZE < OUTPUT_SIZE )); then
            _EMIT_ORIG_TEXT="$OUTPUT" _EMIT_FINAL_TEXT="$STRUCTURED" \
            _warden_emit_event "truncated" "$OUTPUT_SIZE" "$STRUCT_SIZE" "task_structured"
            jq -n --arg text "${STRUCTURED}

[Agent output compressed: $((OUTPUT_SIZE/1024))KB -> $((STRUCT_SIZE/1024))KB structured lines]" \
                '{"modifyOutput":$text}'
            exit 0
        fi
    fi
    # Fall through to generic truncation if structured extraction yielded too little
fi

# Fast path: small outputs (subagent Reads use tighter 10KB threshold)
TRUNCATION_THRESHOLD=20480
if [[ "$IS_SUBAGENT" == true && "$TOOL_NAME" == "Read" ]]; then
    TRUNCATION_THRESHOLD=10240
fi
(( OUTPUT_SIZE <= TRUNCATION_THRESHOLD )) && { _warden_emit_event "allowed" "$OUTPUT_SIZE" "$OUTPUT_SIZE"; _exit_clean_or_suppress; }

# Need actual output content for truncation - extract only when needed
# Skip re-extraction if reminder strip already populated OUTPUT
if [[ "$REMINDER_PRE_STRIPPED" != true ]]; then
    OUTPUT=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
    OUTPUT_SIZE=${#OUTPUT}

    # Re-check after actual extraction (jq length vs bash length may differ)
    (( OUTPUT_SIZE <= TRUNCATION_THRESHOLD )) && { _warden_emit_event "allowed" "$OUTPUT_SIZE" "$OUTPUT_SIZE"; _exit_clean_or_suppress; }
fi

# Binary check: pipe through grep since bash variables can't hold null bytes
if printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null | grep -qP '\x00'; then
    _warden_emit_event "truncated" "$OUTPUT_SIZE" 50 "binary_output"
    jq -n --arg text "[Binary output: $((OUTPUT_SIZE/1024))KB. Use 'file' or redirect.]" '{"modifyOutput":$text}'
    exit 0
fi

# >500KB: suppress entirely
if (( OUTPUT_SIZE > 524288 )); then
    _warden_emit_event "truncated" "$OUTPUT_SIZE" 60 "output_suppressed"
    jq -n --arg text "[Output too large: $((OUTPUT_SIZE/1048576))MB. Use | head or redirect.]" '{"modifyOutput":$text}'
    exit 0
fi

# >20KB: truncate to 10KB (8KB head + 2KB tail)
HEAD="${OUTPUT:0:8000}"
TAIL="${OUTPUT: -2000}"
_EMIT_ORIG_TEXT="$OUTPUT" _EMIT_FINAL_TEXT="${HEAD}${TAIL}" \
_warden_emit_event "truncated" "$OUTPUT_SIZE" 10000 "output_truncated"
jq -n --arg text "${HEAD}
... [$((OUTPUT_SIZE/1024))KB truncated to 10KB] ...
${TAIL}" '{"modifyOutput":$text}'
