#!/bin/bash
# post-tool-use: Track session stats, truncate/suppress large Bash outputs
# Single state file per session, minimal I/O

set -o pipefail

suppress_ok() { echo '{"suppressOutput":true}'; exit 0; }

# Cross-platform timeout wrapper
_timeout() { command -v timeout &>/dev/null && timeout "$@" || command -v gtimeout &>/dev/null && gtimeout "$@" || { shift; "$@"; }; }

# Cross-platform notification
_notify() {
    local urgency="$1" title="$2" body="$3"
    if command -v notify-send &>/dev/null; then
        notify-send -u "$urgency" "$title" "$body"
    elif command -v osascript &>/dev/null; then
        osascript -e "display notification \"$body\" with title \"$title\""
    fi
}

INPUT=$(_timeout 5 cat 2>/dev/null) || exit 0
[[ -z "$INPUT" ]] && exit 0

# Single jq call: extract all needed fields
read -r TOOL_NAME SESSION_ID OUTPUT_SIZE COMMAND < <(
    printf '%s' "$INPUT" | jq -r '[
        .tool_name // "",
        .session_id // "",
        (.tool_response.content[0].text // "" | length),
        .tool_input.command // ""
    ] | @tsv' 2>/dev/null
) || exit 0

[[ "$OUTPUT_SIZE" =~ ^[0-9]+$ ]] || OUTPUT_SIZE=0

# === Session state: single file, single read+write ===
if [[ -n "$SESSION_ID" ]]; then
    STATE_DIR="$HOME/.claude/.statusline"
    STATE_FILE="$STATE_DIR/session-$SESSION_ID"
    mkdir -p "$STATE_DIR"

    # Read previous state (count|top_bytes|top_label|timestamp)
    PREV_COUNT=0; PREV_BYTES=0; PREV_LABEL=""; PREV_TS=0
    if [[ -f "$STATE_FILE" ]]; then
        IFS='|' read -r PREV_COUNT PREV_BYTES PREV_LABEL PREV_TS < "$STATE_FILE" 2>/dev/null
    fi
    [[ "$PREV_COUNT" =~ ^[0-9]+$ ]] || PREV_COUNT=0
    [[ "$PREV_BYTES" =~ ^[0-9]+$ ]] || PREV_BYTES=0

    NEW_COUNT=$((PREV_COUNT + 1))

    # Build tool label for top-output tracking
    TOP_LABEL="$PREV_LABEL"
    TOP_BYTES="$PREV_BYTES"
    if (( OUTPUT_SIZE > PREV_BYTES )); then
        TOP_BYTES="$OUTPUT_SIZE"
        if [[ "$TOOL_NAME" == "Bash" && -n "$COMMAND" ]]; then
            CMD="${COMMAND#"${COMMAND%%[![:space:]]*}"}"
            TOP_LABEL="Bash:${CMD%%[[:space:]]*}"
        else
            TOP_LABEL="$TOOL_NAME"
        fi
    fi

    # Single write: count|top_bytes|top_label|timestamp
    printf '%s|%s|%s|%s\n' "$NEW_COUNT" "$TOP_BYTES" "$TOP_LABEL" "$(date +%s)" > "$STATE_FILE"

    # Budget check every 50 calls (infrequent, fine to be slow)
    if (( NEW_COUNT % 50 == 0 )) && command -v budget-cli &>/dev/null; then
        ALERT_FILE="$STATE_DIR/budget-alert"
        UTIL=$(budget-cli export 2>/dev/null | jq -r '.utilization // 0' | cut -d. -f1)
        if [[ "$UTIL" =~ ^[0-9]+$ ]] && (( UTIL >= 90 )); then
            echo "CRITICAL|$UTIL|$(date +%s)" > "$ALERT_FILE"
            _notify critical "Claude Budget" "${UTIL}%!"
        elif [[ "$UTIL" =~ ^[0-9]+$ ]] && (( UTIL >= 75 )); then
            PREV_LEVEL=$(cut -d'|' -f1 < "$ALERT_FILE" 2>/dev/null || echo "")
            [[ "$PREV_LEVEL" != "WARNING" && "$PREV_LEVEL" != "CRITICAL" ]] && {
                echo "WARNING|$UTIL|$(date +%s)" > "$ALERT_FILE"
                _notify normal "Claude Budget" "${UTIL}%"
            }
        fi
    fi
fi

# Only process Bash outputs for truncation/suppression
[[ "$TOOL_NAME" != "Bash" ]] && suppress_ok

# Fast path: small outputs
(( OUTPUT_SIZE <= 20480 )) && suppress_ok

# Need actual output content for truncation - extract only when needed
OUTPUT=$(printf '%s' "$INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
OUTPUT_SIZE=${#OUTPUT}

# Re-check after actual extraction (jq length vs bash length may differ)
(( OUTPUT_SIZE <= 20480 )) && suppress_ok

# Binary check
if [[ "$OUTPUT" == *$'\x00'* ]]; then
    jq -n --arg text "[Binary output: $((OUTPUT_SIZE/1024))KB. Use 'file' or redirect.]" '{"modifyOutput":$text}'
    exit 0
fi

# >500KB: suppress entirely
if (( OUTPUT_SIZE > 524288 )); then
    jq -n --arg text "[Output too large: $((OUTPUT_SIZE/1048576))MB. Use | head or redirect.]" '{"modifyOutput":$text}'
    exit 0
fi

# >20KB: truncate to 10KB (8KB head + 2KB tail)
HEAD="${OUTPUT:0:8000}"
TAIL="${OUTPUT: -2000}"
jq -n --arg text "${HEAD}
... [$((OUTPUT_SIZE/1024))KB truncated to 10KB] ...
${TAIL}" '{"modifyOutput":$text}'
