#!/bin/bash
# read-compress: Summarize large file reads to reduce tokens
# Extracts structural info (imports, functions, classes) to reduce tokens
#
# Activates for:
# - Read tool results
# - Subagents: files >100 lines
# - Main agent: files >500 lines

set -o pipefail

# Emit JSONL event for clawback accounting (mirrors post-tool-use schema)
_emit_event() {
    local etype="$1" orig_bytes="$2" final_bytes="$3" rule="${4:-}"
    # ~3.5 bytes/token avg across code, prose, structured output (benchmarked)
    local saved=$(( (orig_bytes - final_bytes) * 10 / 35 ))
    (( saved < 0 )) && saved=0
    local now_s; now_s=$(date +%s)
    local start_s; start_s=$(cut -d. -f1 < "$HOME/.claude/.statusline/.session_start" 2>/dev/null || echo "$now_s")
    local ts=$((now_s - start_s))
    local rule_field=""
    [[ -n "$rule" ]] && rule_field="$(printf ',"rule":"%s"' "$rule")"
    local cmd_safe="${FILE_PATH:0:200}"
    cmd_safe="${cmd_safe//\\/\\\\}"
    cmd_safe="${cmd_safe//\"/\\\"}"
    local events_file="$HOME/.claude/.statusline/events.jsonl"
    printf '{"timestamp":%d,"event_type":"%s","tool":"Read","original_cmd":"%s","tokens_saved":%d,"original_output_bytes":%d,"final_output_bytes":%d%s}\n' \
        "$ts" "$etype" "$cmd_safe" "$saved" "$orig_bytes" "$final_bytes" "$rule_field" \
        >> "$events_file" 2>/dev/null

    # Background API token counting: set WARDEN_TOKEN_COUNT=api to enable
    if [[ "${WARDEN_TOKEN_COUNT:-}" == "api" && "$etype" == "truncated" && -n "${_EMIT_ORIG_TEXT:-}" && -n "${_EMIT_FINAL_TEXT:-}" ]]; then
        local _tmpdir; _tmpdir=$(mktemp -d "/tmp/warden-tc.XXXXXX")
        printf '%s' "$_EMIT_ORIG_TEXT" > "$_tmpdir/orig"
        printf '%s' "$_EMIT_FINAL_TEXT" > "$_tmpdir/final"
        local _counter="${BASH_SOURCE[0]%/*}/_token-count-bg"
        ("${WARDEN_PYTHON:-python3}" "$_counter" "$ts" "Read" "$cmd_safe" "$saved" "$rule" "$events_file" "$_tmpdir/orig" "$_tmpdir/final" &)
    fi
}

read -r -t 5 -d '' INPUT || true
[[ -z "$INPUT" ]] && exit 0

# Parse tool info - detect subagent via transcript_path, get file path for type detection
IFS=$'\t' read -r TOOL_NAME TRANSCRIPT_PATH FILE_PATH < <(
    printf '%s' "$INPUT" | jq -r '[.tool_name // "", .transcript_path // "", .tool_input.file_path // ""] | @tsv' 2>/dev/null
) || exit 0

[[ "$TOOL_NAME" != "Read" ]] && exit 0

# Detect subagent via transcript_path patterns
IS_SUBAGENT=false
[[ "$TRANSCRIPT_PATH" == *"/subagents/"* ]] && IS_SUBAGENT=true
[[ "$TRANSCRIPT_PATH" == *"/tmp/"* ]] && IS_SUBAGENT=true

# Get file content
CONTENT=$(printf '%s' "$INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
[[ -z "$CONTENT" ]] && exit 0
ORIGINAL_SIZE=${#CONTENT}
ORIGINAL_CONTENT="$CONTENT"  # Preserved for API token counting

# Strip system reminders appended to Read output by Claude Code infra
REMINDER_STRIPPED=false
case "$CONTENT" in
    *'<system-reminder>'*)
        CONTENT=$(printf '%s' "$CONTENT" | sed '/^<system-reminder>/,/^<\/system-reminder>/d')
        CONTENT=$(printf '%s' "$CONTENT" | sed -e :a -e '/^[[:space:]]*$/{ $d; N; ba; }')
        REMINDER_STRIPPED=true
        _EMIT_ORIG_TEXT="$ORIGINAL_CONTENT" _EMIT_FINAL_TEXT="$CONTENT" \
        _emit_event "truncated" "$ORIGINAL_SIZE" "${#CONTENT}" "system_reminder"
        ;;
esac

# Count lines (fast)
LINES=$(printf '%s' "$CONTENT" | wc -l)

# Detect agent type for threshold adjustment
AGENT_TYPE=""
if [[ "$IS_SUBAGENT" == true && "$TRANSCRIPT_PATH" == *"/subagents/"* ]]; then
    AGENT_ID=$(basename "$TRANSCRIPT_PATH" .jsonl | sed 's/^agent-//')
    [[ "$AGENT_ID" =~ ^[a-zA-Z0-9_-]+$ ]] || AGENT_ID=""
    SUBAGENT_STATE_DIR="$HOME/.claude/.subagent-state"
    if [[ -n "$AGENT_ID" && -f "$SUBAGENT_STATE_DIR/$AGENT_ID" ]]; then
        AGENT_TYPE=$(grep 'AGENT_TYPE=' "$SUBAGENT_STATE_DIR/$AGENT_ID" 2>/dev/null | cut -d= -f2)
    fi
fi

# Helper: emit cleaned content if reminders were stripped, else pass through
_exit_maybe_stripped() {
    if [[ "${REMINDER_STRIPPED:-false}" == true ]]; then
        jq -n --arg text "$CONTENT" '{"modifyOutput":$text}'
    fi
    exit 0
}

# Threshold depends on agent type: code-reviewer/security-auditor=300, subagent=100, main=500
if [[ "$IS_SUBAGENT" == true ]]; then
    if [[ "$AGENT_TYPE" == "code-reviewer" || "$AGENT_TYPE" == "security-auditor" ]]; then
        (( LINES <= 300 )) && _exit_maybe_stripped
    else
        (( LINES <= 100 )) && _exit_maybe_stripped
    fi
else
    (( LINES <= 500 )) && _exit_maybe_stripped
fi

# Config/data file extraction (by extension, before code extraction)
FILE_EXT="${FILE_PATH##*.}"
case "$FILE_EXT" in
    json)
        # Extract top-level and one-deep keys
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^[[:space:]]{0,4}"[^"]+":/ { print }
        ' | head -150)
        ;;
    yml|yaml)
        # Extract top-level keys and document markers
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^---/ { print; next }
            /^[a-zA-Z_][a-zA-Z0-9_-]*:/ { print; next }
            /^- [a-zA-Z]/ { print }
        ' | head -150)
        ;;
    toml|cfg|ini)
        # Extract section headers and root-level keys
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^\[/ { print; next }
            /^[a-zA-Z_][a-zA-Z0-9_-]* *=/ { print }
        ' | head -150)
        ;;
    xml|svg|html)
        # Extract opening tags with attributes
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^[[:space:]]*<[a-zA-Z][^>]*>/ { print }
        ' | head -100)
        ;;
    *)
        SUMMARY=""
        ;;
esac

# If config extraction produced results, use them
if [[ -n "$SUMMARY" ]]; then
    SUMMARY_LINES=$(printf '%s' "$SUMMARY" | wc -l)
    (( SUMMARY_LINES >= LINES )) && _exit_maybe_stripped
    _FINAL="$SUMMARY

[Structure extracted: $LINES lines -> $SUMMARY_LINES keys/sections]
[Use Read with offset/limit for full content]"
    _EMIT_ORIG_TEXT="$ORIGINAL_CONTENT" _EMIT_FINAL_TEXT="$_FINAL" \
    _emit_event "truncated" "$ORIGINAL_SIZE" "${#_FINAL}" "read_compress_config"
    jq -n --arg text "$_FINAL" '{"modifyOutput":$text}'
    exit 0
fi

# Extract structural elements from code files
# Includes: imports, exports, function/class/struct definitions, interfaces, type definitions
# Note: Be careful not to match comments (# in Python is comment, ## in Markdown is header)
SUMMARY=$(printf '%s' "$CONTENT" | awk '
    # Python - imports and definitions (not comments starting with just #)
    /^import [a-zA-Z]/ { print; next }
    /^from [a-zA-Z].* import / { print; next }
    /^class [a-zA-Z]/ { print; next }
    /^def [a-zA-Z]/ { print; next }
    /^async def [a-zA-Z]/ { print; next }
    # JavaScript/TypeScript
    /^import .* from / { print; next }
    /^export (default |const |let |function |class |interface |type |enum )/ { print; next }
    /^const [a-zA-Z].*=/ { print; next }
    /^function [a-zA-Z]/ { print; next }
    /^async function [a-zA-Z]/ { print; next }
    /^class [a-zA-Z]/ { print; next }
    /^interface [a-zA-Z]/ { print; next }
    /^type [a-zA-Z]/ { print; next }
    # Rust
    /^use [a-zA-Z]/ { print; next }
    /^pub (fn |struct |enum |trait |mod |type |use |const )/ { print; next }
    /^fn [a-zA-Z]/ { print; next }
    /^impl [a-zA-Z]/ { print; next }
    /^struct [a-zA-Z]/ { print; next }
    /^enum [a-zA-Z]/ { print; next }
    /^trait [a-zA-Z]/ { print; next }
    /^mod [a-zA-Z]/ { print; next }
    # Go
    /^package [a-zA-Z]/ { print; next }
    /^import \(/ { print; next }
    /^func [a-zA-Z\(]/ { print; next }
    /^type [a-zA-Z]/ { print; next }
    # PHP
    /^<\?php/ { print; next }
    /^namespace [a-zA-Z]/ { print; next }
    /^class [a-zA-Z]/ { print; next }
    /^function [a-zA-Z]/ { print; next }
    /^interface [a-zA-Z]/ { print; next }
    /^trait [a-zA-Z]/ { print; next }
    # Markdown headers (## and deeper, not single #)
    /^#{2,4} / { print; next }
    # Indented definitions (methods in classes)
    /^[[:space:]]+(pub fn |async fn |def |async def |public function |private function |protected function )/ { print }
    /^[[:space:]]+(public |private |protected )[a-zA-Z].*\(/ { print }
' | head -200)

SUMMARY_LINES=$(printf '%s' "$SUMMARY" | wc -l)

# Only output modified content if we actually compressed
(( SUMMARY_LINES >= LINES )) && _exit_maybe_stripped

# Build summary output
_FINAL="$SUMMARY

[Structure extracted: $LINES lines -> $SUMMARY_LINES signatures]
[Use Read with offset/limit for implementation details]"
_EMIT_ORIG_TEXT="$ORIGINAL_CONTENT" _EMIT_FINAL_TEXT="$_FINAL" \
_emit_event "truncated" "$ORIGINAL_SIZE" "${#_FINAL}" "read_compress_code"
jq -n --arg text "$_FINAL" '{"modifyOutput":$text}'
