#!/bin/bash
# read-compress: Summarize large file reads to reduce tokens
# Extracts structural info (imports, functions, classes) to reduce tokens
#
# Activates for:
# - Read tool results
# - Subagents: files >100 lines
# - Main agent: files >500 lines

set -o pipefail

read -r -t 5 -d '' INPUT || true
[[ -z "$INPUT" ]] && exit 0

# Parse tool info - detect subagent via transcript_path, get file path for type detection
IFS=$'\t' read -r TOOL_NAME TRANSCRIPT_PATH FILE_PATH < <(
    printf '%s' "$INPUT" | jq -r '[.tool_name // "", .transcript_path // "", .tool_input.file_path // ""] | @tsv' 2>/dev/null
) || exit 0

[[ "$TOOL_NAME" != "Read" ]] && exit 0

# Detect subagent via transcript_path patterns
IS_SUBAGENT=false
[[ "$TRANSCRIPT_PATH" == *"/subagents/"* ]] && IS_SUBAGENT=true
[[ "$TRANSCRIPT_PATH" == *"/tmp/"* ]] && IS_SUBAGENT=true

# Get file content
CONTENT=$(printf '%s' "$INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
[[ -z "$CONTENT" ]] && exit 0

# Count lines (fast)
LINES=$(printf '%s' "$CONTENT" | wc -l)

# Detect agent type for threshold adjustment
AGENT_TYPE=""
if [[ "$IS_SUBAGENT" == true && "$TRANSCRIPT_PATH" == *"/subagents/"* ]]; then
    AGENT_ID=$(basename "$TRANSCRIPT_PATH" .jsonl | sed 's/^agent-//')
    [[ "$AGENT_ID" =~ ^[a-zA-Z0-9_-]+$ ]] || AGENT_ID=""
    SUBAGENT_STATE_DIR="$HOME/.claude/.subagent-state"
    if [[ -n "$AGENT_ID" && -f "$SUBAGENT_STATE_DIR/$AGENT_ID" ]]; then
        AGENT_TYPE=$(grep 'AGENT_TYPE=' "$SUBAGENT_STATE_DIR/$AGENT_ID" 2>/dev/null | cut -d= -f2)
    fi
fi

# Threshold depends on agent type: code-reviewer/security-auditor=300, subagent=100, main=500
if [[ "$IS_SUBAGENT" == true ]]; then
    if [[ "$AGENT_TYPE" == "code-reviewer" || "$AGENT_TYPE" == "security-auditor" ]]; then
        (( LINES <= 300 )) && exit 0
    else
        (( LINES <= 100 )) && exit 0
    fi
else
    (( LINES <= 500 )) && exit 0
fi

# Config/data file extraction (by extension, before code extraction)
FILE_EXT="${FILE_PATH##*.}"
case "$FILE_EXT" in
    json)
        # Extract top-level and one-deep keys
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^[[:space:]]{0,4}"[^"]+":/ { print }
        ' | head -150)
        ;;
    yml|yaml)
        # Extract top-level keys and document markers
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^---/ { print; next }
            /^[a-zA-Z_][a-zA-Z0-9_-]*:/ { print; next }
            /^- [a-zA-Z]/ { print }
        ' | head -150)
        ;;
    toml|cfg|ini)
        # Extract section headers and root-level keys
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^\[/ { print; next }
            /^[a-zA-Z_][a-zA-Z0-9_-]* *=/ { print }
        ' | head -150)
        ;;
    xml|svg|html)
        # Extract opening tags with attributes
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^[[:space:]]*<[a-zA-Z][^>]*>/ { print }
        ' | head -100)
        ;;
    *)
        SUMMARY=""
        ;;
esac

# If config extraction produced results, use them
if [[ -n "$SUMMARY" ]]; then
    SUMMARY_LINES=$(printf '%s' "$SUMMARY" | wc -l)
    (( SUMMARY_LINES >= LINES )) && exit 0
    jq -n --arg text "$SUMMARY

[Structure extracted: $LINES lines -> $SUMMARY_LINES keys/sections]
[Use Read with offset/limit for full content]" \
        '{"modifyOutput":$text}'
    exit 0
fi

# Extract structural elements from code files
# Includes: imports, exports, function/class/struct definitions, interfaces, type definitions
# Note: Be careful not to match comments (# in Python is comment, ## in Markdown is header)
SUMMARY=$(printf '%s' "$CONTENT" | awk '
    # Python - imports and definitions (not comments starting with just #)
    /^import [a-zA-Z]/ { print; next }
    /^from [a-zA-Z].* import / { print; next }
    /^class [a-zA-Z]/ { print; next }
    /^def [a-zA-Z]/ { print; next }
    /^async def [a-zA-Z]/ { print; next }
    # JavaScript/TypeScript
    /^import .* from / { print; next }
    /^export (default |const |let |function |class |interface |type |enum )/ { print; next }
    /^const [a-zA-Z].*=/ { print; next }
    /^function [a-zA-Z]/ { print; next }
    /^async function [a-zA-Z]/ { print; next }
    /^class [a-zA-Z]/ { print; next }
    /^interface [a-zA-Z]/ { print; next }
    /^type [a-zA-Z]/ { print; next }
    # Rust
    /^use [a-zA-Z]/ { print; next }
    /^pub (fn |struct |enum |trait |mod |type |use |const )/ { print; next }
    /^fn [a-zA-Z]/ { print; next }
    /^impl [a-zA-Z]/ { print; next }
    /^struct [a-zA-Z]/ { print; next }
    /^enum [a-zA-Z]/ { print; next }
    /^trait [a-zA-Z]/ { print; next }
    /^mod [a-zA-Z]/ { print; next }
    # Go
    /^package [a-zA-Z]/ { print; next }
    /^import \(/ { print; next }
    /^func [a-zA-Z\(]/ { print; next }
    /^type [a-zA-Z]/ { print; next }
    # PHP
    /^<\?php/ { print; next }
    /^namespace [a-zA-Z]/ { print; next }
    /^class [a-zA-Z]/ { print; next }
    /^function [a-zA-Z]/ { print; next }
    /^interface [a-zA-Z]/ { print; next }
    /^trait [a-zA-Z]/ { print; next }
    # Markdown headers (## and deeper, not single #)
    /^#{2,4} / { print; next }
    # Indented definitions (methods in classes)
    /^[[:space:]]+(pub fn |async fn |def |async def |public function |private function |protected function )/ { print }
    /^[[:space:]]+(public |private |protected )[a-zA-Z].*\(/ { print }
' | head -200)

SUMMARY_LINES=$(printf '%s' "$SUMMARY" | wc -l)

# Only output modified content if we actually compressed
(( SUMMARY_LINES >= LINES )) && exit 0

# Build summary output
jq -n --arg text "$SUMMARY

[Structure extracted: $LINES lines -> $SUMMARY_LINES signatures]
[Use Read with offset/limit for implementation details]" \
    '{"modifyOutput":$text}'
