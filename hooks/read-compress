#!/bin/bash
# read-compress: Summarize large file reads to reduce tokens
# Extracts structural info (imports, functions, classes) to reduce tokens
#
# Activates for:
# - Read tool results
# - Subagents: files >300 lines
# - Main agent: files >500 lines

set -o pipefail

# Source shared library
source "${BASH_SOURCE[0]%/*}/lib/common.sh"

_warden_read_input || exit 0

# Parse tool info - detect subagent via transcript_path, get file path for type detection
TOOL_NAME=$(_warden_parse_tool_name)
TRANSCRIPT_PATH=$(_warden_parse_transcript_path)
IFS=$'\t' read -r FILE_PATH < <(_warden_parse_tool_input file_path)

[[ "$TOOL_NAME" != "Read" ]] && exit 0

# Detect subagent via transcript_path patterns
IS_SUBAGENT=false
[[ "$TRANSCRIPT_PATH" == *"/subagents/"* ]] && IS_SUBAGENT=true
[[ "$TRANSCRIPT_PATH" == *"/tmp/"* ]] && IS_SUBAGENT=true

# Get file content
CONTENT=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
[[ -z "$CONTENT" ]] && exit 0
ORIGINAL_SIZE=${#CONTENT}
ORIGINAL_CONTENT="$CONTENT"  # Preserved for API token counting

# Strip system reminders appended to Read output by Claude Code infra
REMINDER_STRIPPED=false
case "$CONTENT" in
    *'<system-reminder>'*)
        CONTENT=$(_warden_strip_reminders CONTENT)
        REMINDER_STRIPPED=true
        WARDEN_TOOL_NAME="Read" WARDEN_COMMAND="$FILE_PATH" \
        _warden_emit_event "truncated" "$ORIGINAL_SIZE" "${#CONTENT}" "system_reminder"
        ;;
esac

# Count lines (fast)
LINES=$(printf '%s' "$CONTENT" | wc -l)

# Detect agent type for threshold adjustment
AGENT_TYPE=""
if [[ "$IS_SUBAGENT" == true && "$TRANSCRIPT_PATH" == *"/subagents/"* ]]; then
    AGENT_ID=$(_warden_get_agent_id "$TRANSCRIPT_PATH")
    if [[ -n "$AGENT_ID" ]]; then
        # BUG FIX #1: Add head -1 to prevent multiple line returns from grep
        AGENT_TYPE=$(grep 'AGENT_TYPE=' "$WARDEN_SUBAGENT_STATE_DIR/$AGENT_ID" 2>/dev/null | head -1 | cut -d= -f2)
    fi
fi

# Helper: emit cleaned content if reminders were stripped, else pass through
_exit_maybe_stripped() {
    if [[ "${REMINDER_STRIPPED:-false}" == true ]]; then
        jq -n --arg text "$CONTENT" '{"modifyOutput":$text}'
    fi
    exit 0
}

# Skip compression entirely for non-code files (structural extraction is meaningless)
FILE_EXT="${FILE_PATH##*.}"
case "$FILE_EXT" in
    txt|md|markdown|rst|log|csv|tsv|env|conf|gitignore|dockerignore)
        _exit_maybe_stripped ;;
esac

# BUG FIX #2: Removed dead if/else (both branches identical)
# Threshold: subagent=300, main=500
if [[ "$IS_SUBAGENT" == true ]]; then
    (( LINES <= 300 )) && _exit_maybe_stripped
else
    (( LINES <= 500 )) && _exit_maybe_stripped
fi

# Config/data file extraction (by extension, before code extraction)
case "$FILE_EXT" in
    json)
        # Extract top-level and one-deep keys
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^[[:space:]]{0,4}"[^"]+":/ { print }
        ' | head -150)
        ;;
    yml|yaml)
        # Extract top-level keys and document markers
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^---/ { print; next }
            /^[a-zA-Z_][a-zA-Z0-9_-]*:/ { print; next }
            /^- [a-zA-Z]/ { print }
        ' | head -150)
        ;;
    toml|cfg|ini)
        # Extract section headers and root-level keys
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^\[/ { print; next }
            /^[a-zA-Z_][a-zA-Z0-9_-]* *=/ { print }
        ' | head -150)
        ;;
    xml|svg|html)
        # Extract opening tags with attributes
        SUMMARY=$(printf '%s' "$CONTENT" | awk '
            /^[[:space:]]*<[a-zA-Z][^>]*>/ { print }
        ' | head -100)
        ;;
    *)
        SUMMARY=""
        ;;
esac

# If config extraction produced results, use them
if [[ -n "$SUMMARY" ]]; then
    SUMMARY_LINES=$(printf '%s' "$SUMMARY" | wc -l)
    (( SUMMARY_LINES >= LINES )) && _exit_maybe_stripped
    _FINAL="$SUMMARY

[Structure extracted: $LINES lines -> $SUMMARY_LINES keys/sections]
[Use Read with offset/limit for full content]"
    WARDEN_TOOL_NAME="Read" WARDEN_COMMAND="$FILE_PATH" \
    _warden_emit_event "truncated" "$ORIGINAL_SIZE" "${#_FINAL}" "read_compress_config"
    jq -n --arg text "$_FINAL" '{"modifyOutput":$text}'
    exit 0
fi

# Extract structural elements from code files
# Includes: imports, exports, function/class/struct definitions, interfaces, type definitions
# Note: Be careful not to match comments (# in Python is comment, ## in Markdown is header)
SUMMARY=$(printf '%s' "$CONTENT" | awk '
    # Python - imports and definitions (not comments starting with just #)
    /^import [a-zA-Z]/ { print; next }
    /^from [a-zA-Z].* import / { print; next }
    /^class [a-zA-Z]/ { print; next }
    /^def [a-zA-Z]/ { print; next }
    /^async def [a-zA-Z]/ { print; next }
    # JavaScript/TypeScript
    /^import .* from / { print; next }
    /^export (default |const |let |function |class |interface |type |enum )/ { print; next }
    /^const [a-zA-Z].*=/ { print; next }
    /^function [a-zA-Z]/ { print; next }
    /^async function [a-zA-Z]/ { print; next }
    /^class [a-zA-Z]/ { print; next }
    /^interface [a-zA-Z]/ { print; next }
    /^type [a-zA-Z]/ { print; next }
    # Rust
    /^use [a-zA-Z]/ { print; next }
    /^pub (fn |struct |enum |trait |mod |type |use |const )/ { print; next }
    /^fn [a-zA-Z]/ { print; next }
    /^impl [a-zA-Z]/ { print; next }
    /^struct [a-zA-Z]/ { print; next }
    /^enum [a-zA-Z]/ { print; next }
    /^trait [a-zA-Z]/ { print; next }
    /^mod [a-zA-Z]/ { print; next }
    # Go
    /^package [a-zA-Z]/ { print; next }
    /^import \(/ { print; next }
    /^func [a-zA-Z\(]/ { print; next }
    /^type [a-zA-Z]/ { print; next }
    # PHP
    /^<\?php/ { print; next }
    /^namespace [a-zA-Z]/ { print; next }
    /^class [a-zA-Z]/ { print; next }
    /^function [a-zA-Z]/ { print; next }
    /^interface [a-zA-Z]/ { print; next }
    /^trait [a-zA-Z]/ { print; next }
    # Markdown headers (## and deeper, not single #)
    /^#{2,4} / { print; next }
    # Indented definitions (methods in classes)
    /^[[:space:]]+(pub fn |async fn |def |async def |public function |private function |protected function )/ { print }
    /^[[:space:]]+(public |private |protected )[a-zA-Z].*\(/ { print }
' | head -200)

SUMMARY_LINES=$(printf '%s' "$SUMMARY" | wc -l)

# Only output modified content if we actually compressed
(( SUMMARY_LINES >= LINES )) && _exit_maybe_stripped

# Build summary output
_FINAL="$SUMMARY

[Structure extracted: $LINES lines -> $SUMMARY_LINES signatures]
[Use Read with offset/limit for implementation details]"
WARDEN_TOOL_NAME="Read" WARDEN_COMMAND="$FILE_PATH" \
_warden_emit_event "truncated" "$ORIGINAL_SIZE" "${#_FINAL}" "read_compress_code"
jq -n --arg text "$_FINAL" '{"modifyOutput":$text}'
