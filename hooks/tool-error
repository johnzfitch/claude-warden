#!/bin/bash
# tool-error: Error logging + notifications
# Runs on PostToolUseFailure
#
# All output goes to stderr or log files - NOT stdout
# (stdout could cause issues depending on how this event is processed)

set -euo pipefail

read -r -t 5 -d '' INPUT || true
[[ -z "$INPUT" ]] && exit 0

IFS=$'\t' read -r TOOL_NAME ERROR_MSG < <(
    printf '%s' "$INPUT" | jq -r '[.tool_name // "unknown", (.tool_error // .error // "unknown error")] | @tsv' 2>/dev/null
) || exit 0

# === ERROR LOGGING (to file) ===
{
  echo "=== Tool Error ==="
  echo "Time: $(date)"
  echo "Tool: $TOOL_NAME"
  echo "Error: $ERROR_MSG"
  echo "PWD: $PWD"
  echo "Git: $(git symbolic-ref --short HEAD 2>/dev/null || echo 'N/A')"
  echo ""
} >> "$HOME/.claude/errors.log"

# Keep only last 1000 errors
tail -1000 "$HOME/.claude/errors.log" > "$HOME/.claude/errors.log.tmp" 2>/dev/null && \
  mv "$HOME/.claude/errors.log.tmp" "$HOME/.claude/errors.log" 2>/dev/null || true

# === HINTS TO STDERR (if we want Claude to see them) ===
case "$TOOL_NAME" in
  Bash)
    if echo "$ERROR_MSG" | grep -qi "permission denied"; then
      echo "Hint: May need sudo or file permissions check" >&2
    fi
    if echo "$ERROR_MSG" | grep -qi "command not found"; then
      echo "Hint: Check if command is installed or PATH is set" >&2
    fi
    ;;
  Edit|Write)
    if echo "$ERROR_MSG" | grep -qi "read-only"; then
      echo "Hint: File may be read-only or in a protected directory" >&2
    fi
    ;;
esac

exit 0
